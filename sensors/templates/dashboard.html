<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Temperature Dashboard</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .filters-container {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 15px;
            gap: 15px;
        }
        
        .temperature-toggle {
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 25px;
            padding: 5px;
            display: inline-flex;
        }
        
        .filter-group {
            display: flex;
            flex-direction: column;
            margin: 0 10px;
            min-width: 200px;
        }
        
        .filter-group label {
            margin-bottom: 5px;
            font-weight: bold;
            color: rgba(255,255,255,0.9);
        }
        
        .filter-group select {
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 5px;
            padding: 8px;
            color: white;
            min-height: 36px;
            max-width: 100%;
        }
        
        .filter-group select option {
            background-color: #667eea;
            color: white;
        }
        
        .filter-group select:focus {
            outline: none;
            border-color: rgba(255,255,255,0.6);
        }
        
        .temp-option {
            padding: 8px 16px;
            background: transparent;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 20px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .temp-option.active {
            background: rgba(255,255,255,0.3);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            text-align: center;
        }
        
        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }
        
        .stat-label {
            color: #666;
            margin-top: 5px;
        }
        
        .controls {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .control-group {
            display: inline-block;
            margin-right: 20px;
            margin-bottom: 10px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
        }
        
        .control-group select, .control-group input {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }
        
        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .chart-title {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
        }
        
        .chart-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .small-chart {
            height: 250px;
        }
        
        .large-chart {
            height: 400px;
        }
        
        .status {
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .status.online {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status.offline {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .insights-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .insight-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .insight-title {
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
            display: flex;
            align-items: center;
        }
        
        .insight-icon {
            margin-right: 8px;
            font-size: 1.2em;
        }
        
        .metric-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .metric-row:last-child {
            border-bottom: none;
        }
        
        .metric-label {
            color: #666;
        }
        
        .metric-value {
            font-weight: bold;
            color: #333;
        }
        
        .trend-indicator {
            display: inline-flex;
            align-items: center;
            font-size: 0.9em;
            margin-left: 8px;
        }
        
        .trend-up { color: #e74c3c; }
        .trend-down { color: #3498db; }
        .trend-stable { color: #95a5a6; }
        
        .alert-card {
            background: linear-gradient(135deg, #ff6b6b 0%, #ffa500 100%);
            color: white;
            margin-bottom: 20px;
        }
        
        .info-card {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }
    </style>
</head>
<body>
    </style>
</head>
<body>
    <div class="header">
        <h1>üå°Ô∏è Temperature Monitoring Dashboard</h1>
        <p>Real-time temperature data with historical analysis</p>
        <div class="filters-container">
            <div class="temperature-toggle">
                <button class="temp-option active" onclick="setTemperatureUnit('c')">¬∞C</button>
                <button class="temp-option" onclick="setTemperatureUnit('f')">¬∞F</button>
            </div>
            <div class="filter-group">
                <label for="sensor-filter">Sensors:</label>
                <select id="sensor-filter" multiple="multiple">
                    <option value="">Loading sensors...</option>
                </select>
            </div>
            <div class="filter-group">
                <label for="room-filter">Rooms:</label>
                <select id="room-filter" multiple="multiple">
                    <option value="">Loading rooms...</option>
                </select>
            </div>
        </div>
        <div id="status" class="status offline">Connecting...</div>
    </div>

    <div class="stats-grid">
        <div class="stat-card">
            <div class="stat-value" id="current-temp">--</div>
            <div class="stat-label">Current Temperature (<span id="unit-1">¬∞C</span>)</div>
        </div>
        <div class="stat-card">
            <div class="stat-value" id="min-temp">--</div>
            <div class="stat-label">24h Min (<span id="unit-2">¬∞C</span>)</div>
        </div>
        <div class="stat-card">
            <div class="stat-value" id="max-temp">--</div>
            <div class="stat-label">24h Max (<span id="unit-3">¬∞C</span>)</div>
        </div>
        <div class="stat-card">
            <div class="stat-value" id="avg-temp">--</div>
            <div class="stat-label">24h Average (<span id="unit-4">¬∞C</span>)</div>
        </div>
        <div class="stat-card">
            <div class="stat-value" id="total-readings">--</div>
            <div class="stat-label">Total Readings</div>
        </div>
        <div class="stat-card">
            <div class="stat-value" id="last-update">--</div>
            <div class="stat-label">Last Update</div>
        </div>
    </div>

    <!-- Insights Section -->
    <div class="insights-grid">
        <div class="insight-card" id="temperature-insights">
            <div class="insight-title">
                <span class="insight-icon">üå°Ô∏è</span>
                Temperature Analysis
            </div>
            <div id="temp-analysis-content">
                <div class="metric-row">
                    <span class="metric-label">Loading analysis...</span>
                    <span class="metric-value">--</span>
                </div>
            </div>
        </div>
        
        <div class="insight-card" id="trend-insights">
            <div class="insight-title">
                <span class="insight-icon">üìà</span>
                Recent Trends
            </div>
            <div id="trend-analysis-content">
                <div class="metric-row">
                    <span class="metric-label">Loading trends...</span>
                    <span class="metric-value">--</span>
                </div>
            </div>
        </div>
        
        <div class="insight-card" id="efficiency-insights">
            <div class="insight-title">
                <span class="insight-icon">‚ö°</span>
                System Performance
            </div>
            <div id="efficiency-analysis-content">
                <div class="metric-row">
                    <span class="metric-label">Data collection rate</span>
                    <span class="metric-value" id="collection-rate">--</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Sensor reliability</span>
                    <span class="metric-value" id="sensor-reliability">--</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Average interval</span>
                    <span class="metric-value" id="avg-interval">--</span>
                </div>
            </div>
        </div>
        
        <div class="insight-card" id="environment-insights">
            <div class="insight-title">
                <span class="insight-icon">üè†</span>
                Environment Insights
            </div>
            <div id="environment-analysis-content">
                <div class="metric-row">
                    <span class="metric-label">Loading environment data...</span>
                    <span class="metric-value">--</span>
                </div>
            </div>
        </div>
    </div>

    <div class="controls">
        <div class="control-group">
            <label for="time-range">Time Range:</label>
            <select id="time-range">
                <option value="1">Last Hour</option>
                <option value="6">Last 6 Hours</option>
                <option value="24" selected>Last 24 Hours</option>
                <option value="72">Last 3 Days</option>
                <option value="168">Last Week</option>
            </select>
        </div>
        
        <div class="control-group">
            <label for="comparison-days">Comparison Days:</label>
            <select id="comparison-days">
                <option value="3">Last 3 Days</option>
                <option value="7" selected>Last 7 Days</option>
                <option value="14">Last 14 Days</option>
                <option value="30">Last 30 Days</option>
            </select>
        </div>
    </div>

    <!-- Trend Comparison Charts -->
    <div class="chart-grid">
        <div class="chart-container">
            <div class="chart-title">Last Hour vs Previous Day</div>
            <div id="trend-1h-chart" class="small-chart"></div>
        </div>
        <div class="chart-container">
            <div class="chart-title">Last 4 Hours vs Previous Day</div>
            <div id="trend-4h-chart" class="small-chart"></div>
        </div>
    </div>

    <div class="chart-container">
        <div class="chart-title">Real-time Temperature</div>
        <div id="realtime-chart" class="large-chart"></div>
    </div>

    <div class="chart-container">
        <div class="chart-title">Hourly Temperature Comparison</div>
        <div id="hourly-chart" class="large-chart"></div>
    </div>

    <div class="chart-container">
        <div class="chart-title">Daily Temperature Summary</div>
        <div id="daily-chart" class="large-chart"></div>
    </div>

    <script>
        class TemperatureDashboard {
            constructor() {
                this.updateInterval = 1000; // 1 second for real-time updates
                this.currentUnit = 'c';
                this.chartLayouts = new Map(); // Store chart layouts to preserve zoom
                this.init();
            }

            init() {
                this.setupEventListeners();
                this.startAutoUpdate();
                this.updateAll();
            }

            setupEventListeners() {
                document.getElementById('time-range').addEventListener('change', () => this.updateRealtimeChart());
                document.getElementById('comparison-days').addEventListener('change', () => this.updateHourlyChart());
                
                // Add event listeners for our new filters
                const sensorFilter = document.getElementById('sensor-filter');
                const roomFilter = document.getElementById('room-filter');
                
                // Create a function to update all charts when filters change
                const updateAllCharts = () => {
                    console.log("Filter changed - updating all charts");
                    this.fetchStats();
                    this.updateRealtimeChart();
                    this.updateTrendCharts();
                    this.updateHourlyChart();
                    this.updateDailyChart();
                    this.updateInsights();
                };
                
                // Make sure filters immediately update ALL charts
                sensorFilter.addEventListener('change', updateAllCharts);
                roomFilter.addEventListener('change', updateAllCharts);
                
                // Initialize the filters
                this.loadFilters();
            }
            
            async loadFilters() {
                try {
                    const response = await fetch('/api/filters');
                    const data = await response.json();
                    
                    // Update sensor filter
                    const sensorFilter = document.getElementById('sensor-filter');
                    sensorFilter.innerHTML = '';
                    if (data.sensors && data.sensors.length > 0) {
                        // Add select all option
                        const selectAllOption = document.createElement('option');
                        selectAllOption.value = "all";
                        selectAllOption.textContent = "All Sensors";
                        selectAllOption.selected = true;
                        sensorFilter.appendChild(selectAllOption);
                        
                        // Add individual sensors
                        data.sensors.forEach(sensor => {
                            const option = document.createElement('option');
                            option.value = sensor;
                            option.textContent = sensor;
                            sensorFilter.appendChild(option);
                        });
                    }
                    
                    // Update room filter - completely recreate to avoid stale state
                    const roomFilterParent = document.getElementById('room-filter').parentElement;
                    const oldRoomFilter = document.getElementById('room-filter');
                    
                    // Create new select element
                    const newRoomFilter = document.createElement('select');
                    newRoomFilter.id = 'room-filter';
                    newRoomFilter.multiple = true;
                    
                    // Populate new select element
                    if (data.rooms && data.rooms.length > 0) {
                        // Add select all option
                        const selectAllOption = document.createElement('option');
                        selectAllOption.value = "all";
                        selectAllOption.textContent = "All Rooms";
                        selectAllOption.selected = true;
                        newRoomFilter.appendChild(selectAllOption);
                        
                        // Add individual rooms
                        data.rooms.forEach(room => {
                            const option = document.createElement('option');
                            option.value = room;
                            option.textContent = room;
                            newRoomFilter.appendChild(option);
                        });
                    }
                    
                    // Replace old filter with new one
                    roomFilterParent.replaceChild(newRoomFilter, oldRoomFilter);
                    
                    // Re-attach event listener to new room filter using the shared update function
                    newRoomFilter.addEventListener('change', () => {
                        console.log("Room filter changed - updating all charts");
                        this.fetchStats();
                        this.updateRealtimeChart();
                        
                        // Force complete redraw of trend charts by destroying them first
                        Plotly.purge('trend-1h-chart');
                        Plotly.purge('trend-4h-chart');
                        this.updateTrendCharts();
                        
                        this.updateHourlyChart();
                        this.updateDailyChart();
                        this.updateInsights();
                    });
                } catch (error) {
                    console.error('Error loading filters:', error);
                }
            }
            
            preserveZoom(chartId) {
                const chartDiv = document.getElementById(chartId);
                if (chartDiv && chartDiv.layout) {
                    const layout = JSON.parse(JSON.stringify(chartDiv.layout));
                    this.chartLayouts.set(chartId, {
                        'xaxis.range': layout.xaxis?.range,
                        'yaxis.range': layout.yaxis?.range
                    });
                }
            }
            
            restoreZoom(chartId, layout) {
                const savedLayout = this.chartLayouts.get(chartId);
                if (savedLayout) {
                    if (savedLayout['xaxis.range']) {
                        layout.xaxis = layout.xaxis || {};
                        layout.xaxis.range = savedLayout['xaxis.range'];
                        layout.xaxis.autorange = false;
                    }
                    if (savedLayout['yaxis.range']) {
                        layout.yaxis = layout.yaxis || {};
                        layout.yaxis.range = savedLayout['yaxis.range'];
                        layout.yaxis.autorange = false;
                    }
                }
                return layout;
            }

            async fetchStats() {
                try {
                    const filters = this.getSelectedFilters();
                    
                    // Build URL with filters
                    let url = `/api/stats?unit=${this.currentUnit}`;
                    
                    // Add sensor filters
                    filters.sensors.forEach(sensor => {
                        url += `&sensors[]=${encodeURIComponent(sensor)}`;
                    });
                    
                    // Add room filters
                    filters.rooms.forEach(room => {
                        url += `&room[]=${encodeURIComponent(room)}`;
                    });
                    
                    const response = await fetch(url);
                    const data = await response.json();
                    
                    if (data.error) {
                        console.error('Stats error:', data.error);
                        return null;
                    }
                    
                    const unitSymbol = this.currentUnit === 'f' ? '¬∞F' : '¬∞C';
                    
                    // Update stats display
                    document.getElementById('current-temp').textContent = data.current_temp || '--';
                    document.getElementById('min-temp').textContent = data.min_24h || '--';
                    document.getElementById('max-temp').textContent = data.max_24h || '--';
                    document.getElementById('avg-temp').textContent = data.avg_24h || '--';
                    document.getElementById('total-readings').textContent = data.total_readings || '--';
                    document.getElementById('last-update').textContent = data.last_reading ? new Date(data.last_reading).toLocaleTimeString() : '--';
                    
                    // Update unit labels
                    document.querySelectorAll('[id^="unit-"]').forEach(el => {
                        el.textContent = unitSymbol;
                    });
                    
                    // We don't need to update room filters here anymore
                    // as we're handling that in the loadFilters method
                    
                    // Update status
                    const status = document.getElementById('status');
                    status.textContent = `Online - Last reading: ${data.last_reading ? new Date(data.last_reading).toLocaleTimeString() : 'Never'}`;
                    status.className = 'status online';
                    
                    return data;
                } catch (error) {
                    console.error('Error fetching stats:', error);
                    document.getElementById('status').textContent = 'Offline - Connection error';
                    document.getElementById('status').className = 'status offline';
                    return null;
                }
            }

            async updateRealtimeChart() {
                try {
                    const hours = document.getElementById('time-range').value;
                    const filters = this.getSelectedFilters();
                    
                    // Build URL with filters
                    let url = `/api/realtime?hours=${hours}&unit=${this.currentUnit}`;
                    
                    // Add sensor filters
                    filters.sensors.forEach(sensor => {
                        url += `&sensors[]=${encodeURIComponent(sensor)}`;
                    });
                    
                    // Add room filters
                    filters.rooms.forEach(room => {
                        url += `&room[]=${encodeURIComponent(room)}`;
                    });
                    
                    this.preserveZoom('realtime-chart');
                    
                    const response = await fetch(url);
                    const data = await response.json();
                    
                    const unitSymbol = this.currentUnit === 'f' ? '¬∞F' : '¬∞C';
                    
                    // Group data by sensor if multiple sensors
                    const traces = [];
                    
                    if (data.timestamps.length === 0) {
                        // No data case
                        traces.push({
                            x: [],
                            y: [],
                            type: 'scatter',
                            mode: 'lines+markers',
                            line: { color: '#667eea', width: 2 },
                            marker: { color: '#667eea', size: 4 },
                            name: 'No data'
                        });
                    } else if (data.rooms && data.rooms.length > 0) {
                        // Group by unique sensor/room combinations
                        const uniqueCombos = [];
                        const colors = ['#667eea', '#f093fb', '#4facfe', '#43e97b', '#fa709a', '#ffcc02', '#ff6b6b', '#6a11cb', '#00c9ff', '#f953c6'];
                        
                        for (let i = 0; i < data.timestamps.length; i++) {
                            const combo = `${data.rooms[i]}:${data.sensors ? data.sensors[i] : 'unknown'}`;
                            if (!uniqueCombos.includes(combo)) {
                                uniqueCombos.push(combo);
                            }
                        }
                        
                        uniqueCombos.forEach((combo, comboIndex) => {
                            const [room, sensor] = combo.split(':');
                            const color = colors[comboIndex % colors.length];
                            
                            const indices = [];
                            for (let i = 0; i < data.timestamps.length; i++) {
                                const currentCombo = `${data.rooms[i]}:${data.sensors ? data.sensors[i] : 'unknown'}`;
                                if (currentCombo === combo) {
                                    indices.push(i);
                                }
                            }
                            
                            traces.push({
                                x: indices.map(i => data.timestamps[i]),
                                y: indices.map(i => data.temperatures[i]),
                                type: 'scatter',
                                mode: 'lines+markers',
                                line: { color: color, width: 2 },
                                marker: { color: color, size: 4 },
                                name: `${room} - ${sensor}`
                            });
                        });
                    } else {
                        // Default single trace for all data
                        traces.push({
                            x: data.timestamps,
                            y: data.temperatures,
                            type: 'scatter',
                            mode: 'lines+markers',
                            line: { color: '#667eea', width: 2 },
                            marker: { color: '#667eea', size: 4 },
                            name: 'Temperature'
                        });
                    }
                    
                    let layout = {
                        xaxis: { title: 'Time' },
                        yaxis: { title: `Temperature (${unitSymbol})` },
                        margin: { t: 30, r: 30, b: 50, l: 50 },
                        showlegend: traces.length > 1 // Only show legend if multiple traces
                    };
                    
                    layout = this.restoreZoom('realtime-chart', layout);
                    
                    // Use Plotly.react to avoid flashing
                    Plotly.react('realtime-chart', traces, layout, { responsive: true });
                } catch (error) {
                    console.error('Error updating realtime chart:', error);
                }
            }

            async updateTrendCharts() {
                try {
                    const unitSymbol = this.currentUnit === 'f' ? '¬∞F' : '¬∞C';
                    const filters = this.getSelectedFilters();
                    
                    // Build URL with filters for the trend comparison API (not raw data)
                    let baseUrl = `/api/trend_comparison?unit=${this.currentUnit}`;
                    
                    // Add sensor filters
                    filters.sensors.forEach(sensor => {
                        baseUrl += `&sensors[]=${encodeURIComponent(sensor)}`;
                    });
                    
                    // Add room filters
                    filters.rooms.forEach(room => {
                        baseUrl += `&room[]=${encodeURIComponent(room)}`;
                    });
                    
                    // Save zoom state before updating
                    this.preserveZoom('trend-1h-chart');
                    this.preserveZoom('trend-4h-chart');
                    
                    // Fetch 1-hour trend data from trend_comparison API
                    const response1h = await fetch(`${baseUrl}&hours=1`); 
                    const data1h = await response1h.json();
                    
                    // Process the trend comparison data
                    const traces1h = [];
                    const colors = ['#667eea', '#fa709a', '#4facfe', '#43e97b', '#ffcc02', '#9966cc', '#ff7f50', '#8fbc8f'];
                    
                    if (data1h.current && data1h.previous) {
                        let colorIndex = 0;
                        
                        // Check if we have the new grouped data format
                        if (data1h.current.groups) {
                            // Process current period data
                            for (const [key, groupData] of Object.entries(data1h.current.groups)) {
                                const color = colors[colorIndex % colors.length];
                                
                                traces1h.push({
                                    x: groupData.minutes,
                                    y: groupData.temperatures,
                                    type: 'scatter',
                                    mode: 'lines+markers',
                                    name: `Current: ${groupData.room} - ${groupData.sensor}`,
                                    line: { color, width: 2 },
                                    marker: { size: 3 }
                                });
                                
                                colorIndex++;
                            }
                            
                            // Process previous period data (match colors to current period)
                            if (data1h.previous.groups) {
                                colorIndex = 0; // Reset to match current data colors
                                
                                for (const [key, groupData] of Object.entries(data1h.previous.groups)) {
                                    const color = colors[colorIndex % colors.length];
                                    
                                    traces1h.push({
                                        x: groupData.minutes,
                                        y: groupData.temperatures,
                                        type: 'scatter',
                                        mode: 'lines+markers',
                                        name: `Previous: ${groupData.room} - ${groupData.sensor}`,
                                        line: { color, width: 2, dash: 'dash' },
                                        marker: { size: 3 }
                                    });
                                    
                                    colorIndex++;
                                }
                            }
                        }
                        // Check if we have room and sensor info in flat arrays (backward compatibility)
                        else if (data1h.current.rooms && data1h.current.rooms.length > 0) {
                            // Group by unique room/sensor combinations
                            const currentRoomSensors = {};
                            
                            // First, build a mapping of room:sensor to data indices
                            for (let i = 0; i < data1h.current.minutes.length; i++) {
                                const room = data1h.current.rooms[i];
                                const sensor = data1h.current.sensors ? data1h.current.sensors[i] : 'unknown';
                                const key = `${room}:${sensor}`;
                                
                                if (!currentRoomSensors[key]) {
                                    currentRoomSensors[key] = {
                                        x: [],
                                        y: [],
                                        room,
                                        sensor
                                    };
                                }
                                
                                currentRoomSensors[key].x.push(data1h.current.minutes[i]);
                                currentRoomSensors[key].y.push(data1h.current.temperatures[i]);
                            }
                            
                            // Create a trace for each room:sensor combination
                            for (const key in currentRoomSensors) {
                                const rs = currentRoomSensors[key];
                                traces1h.push({
                                    x: rs.x,
                                    y: rs.y,
                                    type: 'scatter',
                                    mode: 'lines+markers',
                                    name: `Current: ${rs.room} - ${rs.sensor}`,
                                    line: { color: colors[colorIndex % colors.length], width: 2 },
                                    marker: { size: 3 }
                                });
                                colorIndex++;
                            }
                            
                            // Do the same for previous day data
                            if (data1h.previous.rooms && data1h.previous.rooms.length > 0) {
                                const previousRoomSensors = {};
                                colorIndex = 0; // Reset color index to match current data
                                
                                for (let i = 0; i < data1h.previous.minutes.length; i++) {
                                    const room = data1h.previous.rooms[i];
                                    const sensor = data1h.previous.sensors ? data1h.previous.sensors[i] : 'unknown';
                                    const key = `${room}:${sensor}`;
                                    
                                    if (!previousRoomSensors[key]) {
                                        previousRoomSensors[key] = {
                                            x: [],
                                            y: [],
                                            room,
                                            sensor
                                        };
                                    }
                                    
                                    previousRoomSensors[key].x.push(data1h.previous.minutes[i]);
                                    previousRoomSensors[key].y.push(data1h.previous.temperatures[i]);
                                }
                                
                                for (const key in previousRoomSensors) {
                                    const rs = previousRoomSensors[key];
                                    traces1h.push({
                                        x: rs.x,
                                        y: rs.y,
                                        type: 'scatter',
                                        mode: 'lines+markers',
                                        name: `Previous: ${rs.room} - ${rs.sensor}`,
                                        line: { color: colors[colorIndex % colors.length], width: 2, dash: 'dash' },
                                        marker: { size: 3 }
                                    });
                                    colorIndex++;
                                }
                            }
                        } else {
                            // Legacy format with no room/sensor data
                            traces1h.push({
                                x: data1h.current.minutes,
                                y: data1h.current.temperatures,
                                type: 'scatter',
                                mode: 'lines+markers',
                                name: data1h.current.label,
                                line: { color: '#667eea', width: 2 },
                                marker: { size: 3 }
                            });
                            
                            traces1h.push({
                                x: data1h.previous.minutes,
                                y: data1h.previous.temperatures,
                                type: 'scatter',
                                mode: 'lines+markers',
                                name: data1h.previous.label,
                                line: { color: '#fa709a', width: 2, dash: 'dash' },
                                marker: { size: 3 }
                            });
                        }
                    } else {
                        // No data case
                        traces1h.push({
                            x: [],
                            y: [],
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: 'No data available',
                            line: { color: '#667eea', width: 2 },
                            marker: { size: 3 }
                        });
                    }
                        
                        let layout1h = {
                            xaxis: { title: 'Minutes' },
                            yaxis: { title: `Temperature (${unitSymbol})` },
                            margin: { t: 30, r: 30, b: 50, l: 50 },
                            showlegend: true,
                            legend: { x: 0, y: 1, bgcolor: 'rgba(255,255,255,0.8)' }
                        };
                        
                        // Restore zoom if available
                        layout1h = this.restoreZoom('trend-1h-chart', layout1h);
                        
                        // Use Plotly.react instead of purge+newPlot to prevent flashing
                        Plotly.react('trend-1h-chart', traces1h, layout1h, { responsive: true });
                    }
                    
                    // 4 hour trend 
                    const response4h = await fetch(`${baseUrl}&hours=4`);
                    const data4h = await response4h.json();
                    
                    if (data4h.current && data4h.previous) {
                        const traces4h = [];
                        const colors = ['#667eea', '#fa709a', '#4facfe', '#43e97b', '#ffcc02', '#9966cc', '#ff7f50'];
                        let colorIndex = 0;
                        
                        // Check if we have the new grouped data format
                        if (data4h.current.groups) {
                            // Process current period data
                            for (const [key, groupData] of Object.entries(data4h.current.groups)) {
                                const color = colors[colorIndex % colors.length];
                                
                                traces4h.push({
                                    x: groupData.minutes,
                                    y: groupData.temperatures,
                                    type: 'scatter',
                                    mode: 'lines+markers',
                                    name: `Current: ${groupData.room} - ${groupData.sensor}`,
                                    line: { color, width: 2 },
                                    marker: { size: 3 }
                                });
                                
                                colorIndex++;
                            }
                            
                            // Process previous period data
                            if (data4h.previous.groups) {
                                colorIndex = 0; // Reset to match current data colors
                                
                                for (const [key, groupData] of Object.entries(data4h.previous.groups)) {
                                    const color = colors[colorIndex % colors.length];
                                    
                                    traces4h.push({
                                        x: groupData.minutes,
                                        y: groupData.temperatures,
                                        type: 'scatter',
                                        mode: 'lines+markers',
                                        name: `Previous: ${groupData.room} - ${groupData.sensor}`,
                                        line: { color, width: 2, dash: 'dash' },
                                        marker: { size: 3 }
                                    });
                                    
                                    colorIndex++;
                                }
                            }
                        }
                        // Backward compatibility mode with room/sensor arrays
                        else if (data4h.current.rooms && data4h.current.rooms.length > 0) {
                            // Group by unique room/sensor combinations
                            const currentRoomSensors = {};
                            
                            // First, build a mapping of room:sensor to data indices
                            for (let i = 0; i < data4h.current.minutes.length; i++) {
                                const room = data4h.current.rooms[i];
                                const sensor = data4h.current.sensors ? data4h.current.sensors[i] : 'unknown';
                                const key = `${room}:${sensor}`;
                                
                                if (!currentRoomSensors[key]) {
                                    currentRoomSensors[key] = {
                                        x: [],
                                        y: [],
                                        room,
                                        sensor
                                    };
                                }
                                
                                currentRoomSensors[key].x.push(data4h.current.minutes[i]);
                                currentRoomSensors[key].y.push(data4h.current.temperatures[i]);
                            }
                            
                            // Create a trace for each room:sensor combination
                            for (const key in currentRoomSensors) {
                                const rs = currentRoomSensors[key];
                                traces4h.push({
                                    x: rs.x,
                                    y: rs.y,
                                    type: 'scatter',
                                    mode: 'lines+markers',
                                    name: `Current: ${rs.room} - ${rs.sensor}`,
                                    line: { color: colors[colorIndex % colors.length], width: 2 },
                                    marker: { size: 3 }
                                });
                                colorIndex++;
                            }
                        } else {
                            // Default behavior if no room data
                            traces4h.push({
                                x: data4h.current.minutes,
                                y: data4h.current.temperatures,
                                type: 'scatter',
                                mode: 'lines+markers',
                                name: data4h.current.label,
                                line: { color: '#667eea', width: 2 },
                                marker: { size: 3 }
                            });
                        }
                        
                        // Handle previous day data
                        if (data4h.previous.rooms && data4h.previous.rooms.length > 0) {
                            // Group by unique room/sensor combinations
                            const prevRoomSensors = {};
                            
                            // First, build a mapping of room:sensor to data indices
                            for (let i = 0; i < data4h.previous.minutes.length; i++) {
                                const room = data4h.previous.rooms[i];
                                const sensor = data4h.previous.sensors ? data4h.previous.sensors[i] : 'unknown';
                                const key = `${room}:${sensor}`;
                                
                                if (!prevRoomSensors[key]) {
                                    prevRoomSensors[key] = {
                                        x: [],
                                        y: [],
                                        room,
                                        sensor
                                    };
                                }
                                
                                prevRoomSensors[key].x.push(data4h.previous.minutes[i]);
                                prevRoomSensors[key].y.push(data4h.previous.temperatures[i]);
                            }
                            
                            // Create a trace for each room:sensor combination with dashed lines for previous day
                            let colorIndex = 0;
                            for (const key in prevRoomSensors) {
                                const rs = prevRoomSensors[key];
                                traces4h.push({
                                    x: rs.x,
                                    y: rs.y,
                                    type: 'scatter',
                                    mode: 'lines+markers',
                                    name: `Previous: ${rs.room} - ${rs.sensor}`,
                                    line: { color: colors[colorIndex % colors.length], width: 2, dash: 'dash' },
                                    marker: { size: 3 }
                                });
                                colorIndex++;
                            }
                        } else {
                            // Default behavior if no room data for previous
                            traces4h.push({
                                x: data4h.previous.minutes,
                                y: data4h.previous.temperatures,
                                type: 'scatter',
                                mode: 'lines+markers',
                                name: data4h.previous.label,
                                line: { color: '#fa709a', width: 2, dash: 'dash' },
                                marker: { size: 3 }
                            });
                        }
                        
                        let layout4h = {
                            xaxis: { title: 'Minutes' },
                            yaxis: { title: `Temperature (${unitSymbol})` },
                            margin: { t: 30, r: 30, b: 50, l: 50 },
                            showlegend: true,
                            legend: { x: 0, y: 1, bgcolor: 'rgba(255,255,255,0.8)' }
                        };
                        
                        // Restore zoom if available
                        layout4h = this.restoreZoom('trend-4h-chart', layout4h);
                        
                        // Use Plotly.react instead of purge+newPlot to prevent flashing
                        Plotly.react('trend-4h-chart', traces4h, layout4h, { responsive: true });
                    }
                } catch (error) {
                    console.error('Error updating trend charts:', error);
                }
            }
            
            async updateInsights() {
                try {
                    const filters = this.getSelectedFilters();
                    
                    // Build URL with filters
                    let url = `/api/insights?unit=${this.currentUnit}`;
                    
                    // Add sensor filters
                    filters.sensors.forEach(sensor => {
                        url += `&sensors[]=${encodeURIComponent(sensor)}`;
                    });
                    
                    // Add room filters
                    filters.rooms.forEach(room => {
                        url += `&room[]=${encodeURIComponent(room)}`;
                    });
                    
                    const response = await fetch(url);
                    const data = await response.json();
                    
                    const unitSymbol = this.currentUnit === 'f' ? '¬∞F' : '¬∞C';
                    
                    // Temperature Analysis
                    const tempAnalysis = document.getElementById('temp-analysis-content');
                    if (data.temperature_analysis) {
                        const ta = data.temperature_analysis;
                        tempAnalysis.innerHTML = `
                            <div class="metric-row">
                                <span class="metric-label">Current vs 24h avg</span>
                                <span class="metric-value">${ta.current_vs_avg > 0 ? '+' : ''}${ta.current_vs_avg}${unitSymbol}</span>
                            </div>
                            <div class="metric-row">
                                <span class="metric-label">Temperature stability</span>
                                <span class="metric-value">${ta.stability}</span>
                            </div>
                            <div class="metric-row">
                                <span class="metric-label">24h range</span>
                                <span class="metric-value">${ta.range_24h}${unitSymbol} (${ta.range_assessment})</span>
                            </div>
                        `;
                    }
                    
                    // Trend Analysis
                    const trendAnalysis = document.getElementById('trend-analysis-content');
                    if (data.trend_analysis) {
                        const tr = data.trend_analysis;
                        const trendIcon = tr.hourly_trend === 'Rising' ? 'üìà' : tr.hourly_trend === 'Falling' ? 'üìâ' : '‚û°Ô∏è';
                        trendAnalysis.innerHTML = `
                            <div class="metric-row">
                                <span class="metric-label">Recent trend</span>
                                <span class="metric-value">${trendIcon} ${tr.hourly_trend}</span>
                            </div>
                            <div class="metric-row">
                                <span class="metric-label">Hourly change</span>
                                <span class="metric-value">${tr.hourly_change > 0 ? '+' : ''}${tr.hourly_change}${unitSymbol}</span>
                            </div>
                            <div class="metric-row">
                                <span class="metric-label">vs Yesterday</span>
                                <span class="metric-value">${tr.vs_yesterday}</span>
                            </div>
                        `;
                    }
                    
                    // System Performance
                    if (data.system_performance) {
                        const sp = data.system_performance;
                        document.getElementById('collection-rate').textContent = sp.collection_rate;
                        document.getElementById('sensor-reliability').textContent = sp.reliability;
                        document.getElementById('avg-interval').textContent = sp.avg_interval;
                    }
                    
                    // Environment Insights
                    const envAnalysis = document.getElementById('environment-analysis-content');
                    if (data.environment_insights) {
                        const ei = data.environment_insights;
                        envAnalysis.innerHTML = `
                            <div class="metric-row">
                                <span class="metric-label">Warmest time</span>
                                <span class="metric-value">üåÖ ${ei.warmest_hour}</span>
                            </div>
                            <div class="metric-row">
                                <span class="metric-label">Coolest time</span>
                                <span class="metric-value">üåô ${ei.coolest_hour}</span>
                            </div>
                            <div class="metric-row">
                                <span class="metric-label">Daily variation</span>
                                <span class="metric-value">${ei.daily_variation}${unitSymbol} (${ei.pattern_strength})</span>
                            </div>
                        `;
                    }
                    
                    // Handle alerts
                    this.displayAlerts(data.alerts);
                    
                } catch (error) {
                    console.error('Error updating insights:', error);
                }
            }
            
            displayAlerts(alerts) {
                // Remove existing alert cards
                document.querySelectorAll('.alert-card').forEach(card => card.remove());
                
                if (alerts && alerts.length > 0) {
                    const header = document.querySelector('.header');
                    alerts.forEach(alert => {
                        const alertCard = document.createElement('div');
                        alertCard.className = 'insight-card alert-card';
                        alertCard.innerHTML = `
                            <div class="insight-title">
                                <span class="insight-icon">‚ö†Ô∏è</span>
                                Alert: ${alert.type.replace('_', ' ').toUpperCase()}
                            </div>
                            <div style="margin-top: 10px;">
                                ${alert.message}
                            </div>
                        `;
                        header.insertAdjacentElement('afterend', alertCard);
                    });
                }
            }

            async updateHourlyChart() {
                try {
                    const days = document.getElementById('comparison-days').value;
                    const filters = this.getSelectedFilters();
                    
                    // Build URL with filters
                    let url = `/api/hourly_comparison?days=${days}&unit=${this.currentUnit}`;
                    
                    // Add sensor filters
                    filters.sensors.forEach(sensor => {
                        url += `&sensors[]=${encodeURIComponent(sensor)}`;
                    });
                    
                    // Add room filters
                    filters.rooms.forEach(room => {
                        url += `&room[]=${encodeURIComponent(room)}`;
                    });
                    
                    const response = await fetch(url);
                    const data = await response.json();
                    
                    const unitSymbol = this.currentUnit === 'f' ? '¬∞F' : '¬∞C';
                    
                    this.preserveZoom('hourly-chart');
                    
                    const traces = [];
                    const colors = ['#667eea', '#f093fb', '#4facfe', '#43e97b', '#fa709a', '#ffcc02', '#ff6b6b', '#9966cc', '#ff7f50'];
                    let colorIndex = 0;
                    
                    // Check if we're dealing with the new grouped data format
                    if (data.grouped) {
                        // New format with room/sensor grouping
                        for (const [roomSensor, dateData] of Object.entries(data.grouped)) {
                            const [room, sensor] = roomSensor.split(':');
                            const color = colors[colorIndex % colors.length];
                            colorIndex++;
                            
                            for (const [date, hourlyData] of Object.entries(dateData)) {
                                const hours = Array.from({length: 24}, (_, i) => i);
                                const temperatures = hours.map(hour => hourlyData[hour] !== undefined ? hourlyData[hour] : null);
                                
                                // Filter out null values for better line rendering
                                const validHours = [];
                                const validTemps = [];
                                for (let i = 0; i < hours.length; i++) {
                                    if (temperatures[i] !== null && temperatures[i] !== undefined) {
                                        validHours.push(hours[i]);
                                        validTemps.push(temperatures[i]);
                                    }
                                }
                                
                                traces.push({
                                    x: validHours,
                                    y: validTemps,
                                    type: 'scatter',
                                    mode: 'lines+markers',
                                    name: `${date} - ${room} - ${sensor}`,
                                    line: { color, width: 2 },
                                    marker: { size: 4 }
                                });
                            }
                        }
                    } else {
                        // Legacy format or single room/sensor response
                        for (const [date, hourlyData] of Object.entries(data)) {
                            const hours = [];
                            const temperatures = [];
                            
                            for (const [hour, temp] of Object.entries(hourlyData)) {
                                if (temp !== null) {
                                    hours.push(parseInt(hour));
                                    temperatures.push(temp);
                                }
                            }
                            
                            // Sort by hour for proper line rendering
                            const sortedIndices = hours.map((_, i) => i)
                                .sort((a, b) => hours[a] - hours[b]);
                            
                            traces.push({
                                x: sortedIndices.map(i => hours[i]),
                                y: sortedIndices.map(i => temperatures[i]),
                                type: 'scatter',
                                mode: 'lines+markers',
                                name: date,
                                line: { color: colors[colorIndex % colors.length], width: 2 },
                                marker: { size: 4 }
                            });
                            
                            colorIndex++;
                        }
                    }
                                
                                traces.push({
                                    x: hours,
                                    y: cleanHourlyData,
                                    type: 'scatter',
                                    mode: 'lines+markers',
                                    name: `${date} - ${room} - ${sensor}`,
                                    line: { color: colors[colorIndex % colors.length], width: 2 },
                                    marker: { size: 4 }
                                });
                                colorIndex++;
                            }
                        }
                    } else {
                        // Fallback to original format if raw data isn't available
                        for (const [date, hourlyData] of Object.entries(data)) {
                            const hours = Array.from({length: 24}, (_, i) => i);
                            const temps = hours.map(hour => hourlyData[hour] || null);
                            
                            traces.push({
                                x: hours,
                                y: temps,
                                type: 'scatter',
                                mode: 'lines+markers',
                                name: date,
                                line: { color: colors[colorIndex % colors.length], width: 2 },
                                marker: { size: 4 }
                            });
                            colorIndex++;
                        }
                    }
                    
                    let layout = {
                        xaxis: { title: 'Hour of Day', tickmode: 'linear', dtick: 2 },
                        yaxis: { title: `Temperature (${unitSymbol})` },
                        margin: { t: 30, r: 30, b: 50, l: 50 },
                        showlegend: true,
                        legend: { orientation: 'h', y: -0.2 }
                    };
                    
                    layout = this.restoreZoom('hourly-chart', layout);
                    
                    // Use Plotly.react to avoid flashing
                    Plotly.react('hourly-chart', traces, layout, { responsive: true });
                } catch (error) {
                    console.error('Error updating hourly chart:', error);
                }
            }

            async updateDailyChart() {
                try {
                    const filters = this.getSelectedFilters();
                    
                    // Build URL with filters
                    let url = `/api/daily_summary?days=30&unit=${this.currentUnit}`;
                    
                    // Add sensor filters
                    filters.sensors.forEach(sensor => {
                        url += `&sensors[]=${encodeURIComponent(sensor)}`;
                    });
                    
                    // Add room filters
                    filters.rooms.forEach(room => {
                        url += `&room[]=${encodeURIComponent(room)}`;
                    });
                    
                    const response = await fetch(url);
                    const data = await response.json();
                    
                    const unitSymbol = this.currentUnit === 'f' ? '¬∞F' : '¬∞C';
                    
                    this.preserveZoom('daily-chart');
                    
                    if (!Array.isArray(data) || data.length === 0) {
                        console.log('No daily summary data available');
                        return;
                    }
                    
                    const dates = data.map(d => d.date);
                    const mins = data.map(d => d.min);
                    const maxs = data.map(d => d.max);
                    const avgs = data.map(d => d.avg);
                    
                    const traces = [
                        {
                            x: dates,
                            y: mins,
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: 'Min',
                            line: { color: '#4facfe', width: 2 },
                            marker: { size: 4 }
                        },
                        {
                            x: dates,
                            y: avgs,
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: 'Average',
                            line: { color: '#667eea', width: 2 },
                            marker: { size: 4 }
                        },
                        {
                            x: dates,
                            y: maxs,
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: 'Max',
                            line: { color: '#fa709a', width: 2 },
                            marker: { size: 4 }
                        }
                    ];
                    
                    let layout = {
                        xaxis: { title: 'Date' },
                        yaxis: { title: `Temperature (${unitSymbol})` },
                        margin: { t: 30, r: 30, b: 50, l: 50 },
                        showlegend: true,
                        legend: { orientation: 'h', y: -0.2 }
                    };
                    
                    layout = this.restoreZoom('daily-chart', layout);
                    
                    // Use Plotly.react to avoid flashing
                    Plotly.react('daily-chart', traces, layout, { responsive: true });
                } catch (error) {
                    console.error('Error updating daily chart:', error);
                }
            }

            async updateAll() {
                await this.fetchStats();
                await this.updateRealtimeChart();
                await this.updateHourlyChart();
                await this.updateDailyChart();
                await this.updateTrendCharts();
                await this.updateInsights();
            }

            startAutoUpdate() {
                // Fast updates for stats and insights only
                setInterval(() => {
                    this.fetchStats();
                    this.updateInsights();
                }, this.updateInterval);
                
                // Medium frequency updates for realtime chart
                setInterval(() => {
                    this.updateRealtimeChart();
                }, this.updateInterval * 3); // Every 3 seconds
                
                // Less frequent updates for trend charts to reduce flashing
                setInterval(() => {
                    this.updateTrendCharts();
                }, this.updateInterval * 10); // Every 10 seconds
                
                // Slowest updates for historical charts
                setInterval(() => {
                    this.updateHourlyChart();
                    this.updateDailyChart();
                }, this.updateInterval * 60); // Every 60 seconds
            }
            
            getSelectedFilters() {
                const sensorFilter = document.getElementById('sensor-filter');
                const roomFilter = document.getElementById('room-filter');
                
                try {
                    // Get selected sensors
                    const selectedSensors = Array.from(sensorFilter.selectedOptions)
                        .filter(option => option.value !== "all")
                        .map(option => option.value);
                    
                    // Get selected rooms
                    const selectedRooms = Array.from(roomFilter.selectedOptions)
                        .filter(option => option.value !== "all")
                        .map(option => option.value);
                    
                    // Check if "All" is selected
                    const allSensorsSelected = Array.from(sensorFilter.selectedOptions)
                        .some(option => option.value === "all");
                    
                    const allRoomsSelected = Array.from(roomFilter.selectedOptions)
                        .some(option => option.value === "all");
                    
                    const filters = {
                        sensors: allSensorsSelected ? [] : selectedSensors,
                        rooms: allRoomsSelected ? [] : selectedRooms
                    };
                    
                    console.log("Applied filters:", filters);
                    return filters;
                } catch (error) {
                    console.error("Error getting filters:", error);
                    // Return empty arrays as fallback
                    return { sensors: [], rooms: [] };
                }
            }
        }

        // Global functions for temperature unit switching
        function setTemperatureUnit(unit) {
            const dashboard = window.temperatureDashboard;
            if (dashboard) {
                dashboard.currentUnit = unit;
                
                // Update button states
                document.querySelectorAll('.temp-option').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector(`[onclick="setTemperatureUnit('${unit}')"]`).classList.add('active');
                
                // Update all charts and stats
                dashboard.updateAll();
            }
        }

        // Initialize dashboard when page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.temperatureDashboard = new TemperatureDashboard();
        });
    </script>
</body>
</html>
